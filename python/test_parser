#!/usr/bin/env python3

import sys
from pathlib import Path

from veles.data.bindata import BinData
from veles.defs.symbol import Symbol
from veles.parser.parser import *
from veles.parser.compile import compile_parser
from veles.defs.sexpr import parse_sexpr

ns = compile_parser(parse_sexpr(
    Path(sys.argv[1]).read_text()
))

for struct in ns.structs.values():
    print(f'{struct.name}:')
    for field in struct.fields.values():
        print(f'\t{field.name}: {field}')


class IncompleteException(Exception): pass
class MissingFieldException(IncompleteException): pass
class ComputationError(Exception): pass


def sext(val, bit):
    if val & (1 << bit):
        return val - (2 << bit)
    return val


class Indenter:
    def __init__(self, printer):
        self.printer = printer

    def __enter__(self):
        self.printer.ilevel += 1

    def __exit__(self, exc_type, exc_value, traceback):
        self.printer.ilevel -= 1


class Printer:
    def __init__(self):
        self.ilevel = 0
        self.indent = Indenter(self)

    def __call__(self, pos, str):
        indent = '    ' * self.ilevel
        if pos is None:
            print('--------{} {}'.format(indent, str))
        else:
            print('{:08x}{} {}'.format(pos, indent, str))


struct_counter = 0


class ParsedStruct:
    def __init__(self, data, pos, struct, name, params):
        global struct_counter
        self.data = data
        self.pos_start = pos
        self.pos_end = None
        self.struct = struct
        self.name = name
        self.entries = []
        self.fields = {}
        self.params = params
        self.index = struct_counter
        struct_counter += 1

    def print(self, printer):
        printer(self.pos_start, '{} = struct {} [#{}] {{'.format(self.name, self.struct.name, self.index))
        with printer.indent:
            for param, val in self.params.items():
                printer(self.pos_start, 'param {} = {}'.format(param.name, val))
            for entry in self.entries:
                entry.print(printer)
        printer(self.pos_end, '}')

    def get_field_val(self, field):
        if field not in self.fields:
            raise MissingFieldException('missing field {} of {} at {:08x}'.format(field.name, self.struct.name, self.pos_start), self, field)
        pfield = self.fields[field]
        if isinstance(pfield, (ParsedFieldInt, ParsedComputedInt)):
            return pfield.value
        elif isinstance(pfield, ParsedFieldBindata):
            return pfield.raw_value
        elif isinstance(pfield, ParsedIntMap):
            return pfield
        elif isinstance(pfield, ParsedFieldRef):
            return pfield.ref
        else:
            print(pfield)
            assert 0

    def get_param_val(self, param):
        if param not in self.params:
            raise IncompleteException('missing param {} of {} at {:08x}'.format(param.name, self.struct.name, self.pos_start))
        return self.params[param]

    def get_self(self):
        return self

    def __str__(self):
        return 'struct {} #{}'.format(self.struct.name, self.index)


class ParsedLoopState:
    def __init__(self, parent, vars):
        self.parent = parent
        self.vars = vars
        self.last = None

    def get_field_val(self, field):
        return self.parent.get_field_val(field)

    def get_param_val(self, param):
        return self.parent.get_param_val(param)

    def get_loop_var_val(self, var):
        if var not in self.vars:
            raise IncompleteException('missing var {} of {} at {:08x}'.format(var.name, self.parent.struct.name, self.parent.pos_start))
        return self.vars[var]

    def get_last(self):
        return self.last

    def get_self(self):
        return self.parent.get_self()


class ParsedChildArray:
    def __init__(self, data, pos_start, field, num):
        self.data = data
        self.pos_start = pos_start
        self.pos_end = None
        self.field = field
        self.num = num
        self.children = []
        self.states = []

    def print(self, printer):
        printer(self.pos_start, 'struct {}[] {} = {{'.format(self.field.type.struct.name, self.field.name))
        with printer.indent:
            for i, child in enumerate(self.children):
                state = self.states[i]
                for var, val in state.vars.items():
                    printer(child.pos_start, 'loop-var {} = {}'.format(var.name, val))
                child.print(printer)
            state = self.states[-1]
            for var, val in state.vars.items():
                printer(self.pos_end, 'loop-var {} = {}'.format(var.name, val))
        printer(self.pos_end, '}')


class ParsedField:
    def __init__(
            self,
            data,
            pos_start,
            pos_end,
            field,
            repacker,
            num,
            raw_value):
        self.data = data
        self.pos_start = pos_start
        self.pos_end = pos_end
        self.field = field
        self.repacker = repacker
        self.num = num
        self.raw_value = raw_value


class ParsedFieldBindata(ParsedField):
    def __init__(self,
            data, pos_start, pos_end, field,
            repacker, num, raw_value,
            display):
        super().__init__(data, pos_start, pos_end, field,
                repacker, num, raw_value)
        self.display = display

    def print(self, printer):
        if isinstance(self.display, ParserBinDisplayRaw):
            printer(self.pos_start, 'raw {} = {}'.format(self.field.name, self.raw_value))
        elif isinstance(self.display, ParserBinDisplayString):
            value = '"'
            for c in self.raw_value:
                if c in {ord('\"'), ord('\\')}:
                    value += '\\' + c
                elif c in range(0x20, 0x7f):
                    value += chr(c)
                elif c == ord('\n'):
                    value += '\\n'
                elif c == ord('\t'):
                    value += '\\t'
                else:
                    value += '\\x{:02x}'.format(c)
            value += '"'
            printer(self.pos_start, 'string {} = {} [{}]'.format(self.field.name, value, self.raw_value))
        elif isinstance(self.display, ParserBinDisplayUnsigned):
            value = ', '.join(str(x) for x in self.raw_value)
            printer(self.pos_start, 'uint[] {} = {} [{}]'.format(self.field.name, value, self.raw_value))
        elif isinstance(self.display, ParserBinDisplaySigned):
            value = ', '.join(str(sext(x, self.raw_value.width - 1)) for x in self.raw_value)
            printer(self.pos_start, 'sint[] {} = {} [{}]'.format(self.field.name, value, self.raw_value))
        else:
            print(self.display)
            assert 0


class ParsedFieldInt(ParsedField):
    def __init__(self,
            data, pos_start, pos_end, field,
            repacker, num, raw_value,
            value):
        super().__init__(data, pos_start, pos_end, field,
                repacker, num, raw_value)
        self.value = value

    def print(self, printer):
        printer(self.pos_start, 'int {} = {} [{}]'.format(self.field.name, self.value, self.raw_value))


class ParsedFieldIntArray(ParsedField):
    def __init__(self,
            data, pos_start, pos_end, field,
            repacker, num, raw_value,
            values):
        super().__init__(data, pos_start, pos_end, field,
                repacker, num, raw_value)
        self.values = values

    def print(self, printer):
        printer(self.pos_start, 'int[] {} = {} [{}]'.format(self.field.name, ', '.join(str(x) for x in self.values), self.raw_value))


class ParsedFieldRef(ParsedField):
    def __init__(self,
            data, pos_start, pos_end, field,
            repacker, num, raw_value,
            index, ref):
        super().__init__(data, pos_start, pos_end, field,
                repacker, num, raw_value)
        self.index = index
        self.ref = ref

    def print(self, printer):
        printer(self.pos_start, '{} {} = {} [{}] [{}]'.format(self.field.type, self.field.name, self.ref, self.index, self.raw_value))


class ParsedFieldRefArray(ParsedField):
    def __init__(self,
            data, pos_start, pos_end, field,
            repacker, num, raw_value,
            indices, refs):
        super().__init__(data, pos_start, pos_end, field,
                repacker, num, raw_value)
        self.indices = indices
        self.refs = refs

    def print(self, printer):
        printer(self.pos_start, '{} {} = {} [{}] [{}]'.format(
            self.field.type, self.field.name,
            ', '.join(str(ref) for ref in self.refs),
            ', '.join(str(index) for index in self.indices),
            self.raw_value))


class ParsedComputedInt:
    def __init__(self, data, pos, field, value):
        self.data = data
        self.pos = pos
        self.field = field
        self.value = value

    def print(self, printer):
        printer(self.pos, 'int {} = {} [computed]'.format(self.field.name, self.value))


class ParsedIntMap:
    def __init__(self, data, pos, field):
        global struct_counter
        self.data = data
        self.pos = pos
        self.field = field
        self.lo = None
        self.hi = None
        self.values = {}
        self.index = struct_counter
        struct_counter += 1

    def print(self, printer):
        # XXX bounds
        printer(self.pos, '{}[int] {} [#{}] = {{'.format(self.field.type.subtype, self.field.name, self.index))
        with printer.indent:
            for k, v in sorted(self.values.items()):
                printer(self.pos, '[{}] = {}'.format(k, v))
        printer(self.pos, '}}')

    def __str__(self):
        return '{} #{}'.format(self.field.type, self.index)

    def lookup(self, index):
        # XXX
        if index in self.values:
            return self.values[index]
        return ...


with open(sys.argv[3], 'rb') as f:
    d = f.read()
    d = BinData(8, d)


def eval_expr(env, expr):
    if isinstance(expr, (ParserExprConstInt, ParserExprConstBindata)):
        return expr.value
    if isinstance(expr, ParserExprSub):
        return eval_expr(env, expr.e1) - eval_expr(env, expr.e2)
    if isinstance(expr, ParserExprAdd):
        return eval_expr(env, expr.e1) + eval_expr(env, expr.e2)
    if isinstance(expr, ParserExprEqInt):
        return BinData(1, [eval_expr(env, expr.e1) == eval_expr(env, expr.e2)])
    if isinstance(expr, ParserExprField):
        return env.get_field_val(expr.field)
    if isinstance(expr, ParserExprLoopVar):
        return env.get_loop_var_val(expr.var)
    if isinstance(expr, ParserExprParam):
        return env.get_param_val(expr.param)
    if isinstance(expr, ParserExprGetField):
        sub = eval_expr(env, expr.expr)
        return sub.get_field_val(expr.field)
    if isinstance(expr, ParserExprLast):
        return env.get_last()
    if isinstance(expr, ParserExprSelf):
        return env.get_self()
    if isinstance(expr, ParserExprNilStruct):
        return None
    print(expr)
    assert 0

def eval_pred(struct, pred, expr):
    if isinstance(pred, ParserPredEq):
        val = eval_expr(struct, pred.val)
        return val == expr
    print(pred)
    assert 0


def parse_struct(data, pos, struct, name, params):
    res = ParsedStruct(data, pos, struct, name, params)
    res.pos_end = eval_ops(res, data, pos, struct.ops)
    return res

def eval_ops(res, data, pos, ops):
    for op in ops:
        if isinstance(op, ParserOpField):
            if op.field in res.fields:
                raise ValueError('duplicate field {}'.format(op.field))
            num = eval_expr(res, op.num)
            repacker = op.repacker
            size = repacker.repack_size(num)
            pos_end = pos + size
            if pos_end > len(data):
                # XXX
                return None
            raw_value = repacker.repack(data, pos, num)
            if isinstance(op.interp, ParserFieldInterpBindata):
                field = ParsedFieldBindata(
                    data,
                    pos,
                    pos_end,
                    op.field,
                    repacker,
                    num,
                    raw_value,
                    op.interp.display,
                )
            elif isinstance(op.interp, ParserFieldInterpInt):
                value = raw_value[0]
                if op.interp.signed:
                    if value & (1 << (raw_value.width - 1)):
                        value -= 1 << raw_value.width
                field = ParsedFieldInt(
                    data,
                    pos,
                    pos_end,
                    op.field,
                    repacker,
                    num,
                    raw_value,
                    value,
                )
            elif isinstance(op.interp, ParserFieldInterpIntArray):
                values = []
                for value in raw_value:
                    if op.interp.signed:
                        if value & (1 << (raw_value.width - 1)):
                            value -= 1 << raw_value.width
                    values.append(value)
                field = ParsedFieldIntArray(
                    data,
                    pos,
                    pos_end,
                    op.field,
                    repacker,
                    num,
                    raw_value,
                    values,
                )
            elif isinstance(op.interp, ParserFieldInterpMapLookup):
                map = eval_expr(res, op.interp.map)
                index = raw_value[0]
                ref = map.lookup(index)
                field = ParsedFieldRef(
                    data,
                    pos,
                    pos_end,
                    op.field,
                    repacker,
                    num,
                    raw_value,
                    index,
                    ref,
                )
            elif isinstance(op.interp, ParserFieldInterpMapLookupArray):
                map = eval_expr(res, op.interp.map)
                indices = list(raw_value)
                refs = [map.lookup(index) for index in indices]
                field = ParsedFieldRefArray(
                    data,
                    pos,
                    pos_end,
                    op.field,
                    repacker,
                    num,
                    raw_value,
                    indices,
                    refs,
                )
            else:
                print(op.interp)
                assert 0
            pos = pos_end
            res.fields[op.field] = field
            res.entries.append(field)
        elif isinstance(op, ParserOpCompute):
            if op.field in res.fields:
                raise ValueError('duplicate field {}'.format(op.field))
            value = eval_expr(res, op.expr)
            field = ParsedComputedInt(
                data,
                pos,
                op.field,
                value,
            )
            res.fields[op.field] = field
            res.entries.append(field)
        elif isinstance(op, (ParserOpChildLoop, ParserOpChildArray)):
            is_array = isinstance(op, ParserOpChildArray)
            if is_array:
                num = eval_expr(res, op.num)
            array = ParsedChildArray(data, pos, op.field, num)
            res.entries.append(array)
            init_vars = {
                var: eval_expr(res, var.initial)
                for var in op.vars
            }
            state = ParsedLoopState(res, init_vars)
            array.states.append(state)
            idx = 0
            while True:
                if is_array:
                    end = idx == num
                else:
                    end = bool(eval_expr(state, op.end)[0])
                if end:
                    break
                params = {}
                for param, expr in op.params:
                    params[param] = eval_expr(state, expr)
                sub = parse_struct(data, pos, op.field.type.struct, '[{}]'.format(idx), params)
                state.last = sub
                array.children.append(sub)
                if sub.pos_end is None:
                    return None
                pos = sub.pos_end
                next_vars = {
                    var: eval_expr(state, var.next)
                    for var in op.vars
                }
                state = ParsedLoopState(res, next_vars)
                idx += 1
                array.states.append(state)
            array.pos_end = pos
        elif isinstance(op, ParserOpMatch):
            expr = eval_expr(res, op.expr)
            for case in op.cases:
                if eval_pred(res, case.pred, expr):
                    pos = eval_ops(res, data, pos, case.ops)
                    break
            else:
                print('no case {}'.format(expr))
                if op.can_read_input():
                    return None
                # XXX message
        elif isinstance(op, ParserOpMakeIntMap):
            if op.field in res.fields:
                raise ValueError('duplicate field {}'.format(op.field))
            field = ParsedIntMap(data, pos, op.field)
            res.fields[op.field] = field
            res.entries.append(field)
        elif isinstance(op, ParserOpIntMapStore):
            map = eval_expr(res, op.map)
            index = eval_expr(res, op.index)
            val = eval_expr(res, op.val)
            if index in map.values:
                raise ValueError('duplicate value for index {}'.format(index))
            map.values[index] = val
        elif isinstance(op, ParserOpIntMapBounds):
            map = eval_expr(res, op.map)
            lo = eval_expr(res, op.lo)
            hi = eval_expr(res, op.hi)
            if map.hi is not None or map.lo is not None:
                raise ValueError('bounds already set')
            # XXX validate bounds
            map.lo = lo
            map.hi = hi
        else:
            print(op)
            assert 0
    return pos

s = parse_struct(d, 0, ns.structs[sys.argv[2]], 'root', {})

print(s.pos_end, len(d))

s.print(Printer())
